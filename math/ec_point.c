/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <stdint.h>
#include <gmp.h>
#include <string.h>

#ifndef _Included_com_archer_math_EcPoint
#define _Included_com_archer_math_EcPoint


#ifdef __cplusplus
extern "C" {
#endif
void math_point_mul(mpz_t x, mpz_t y, mpz_t d, mpz_t p, mpz_t a, mpz_t b, mpz_t gx, mpz_t gy) {
  char *bits = mpz_get_str(NULL, 2, d);
  uint32_t len = strlen(bits);
  mpz_t inv, k, tx, ty;
  mpz_init(inv);
  mpz_init(k);
  mpz_init_set(tx, gx);
  mpz_init_set(ty, gy);
  for(int i = 1; i < len; i++) {

    /**double**/ 
    mpz_mul_ui(inv, ty, 2);
    mpz_invert(inv, inv, p);
    mpz_mul(k, tx, tx);
    mpz_mul_ui(k, k, 3);
    mpz_add(k, k, a);
    mpz_mul(k, k, inv);
    mpz_mod(k, k, p);
    //x
    mpz_pow_ui(x, k, 2);
    mpz_sub(x, x, tx);
    mpz_sub(x, x, tx);
    mpz_mod(x, x, p);
    //y
    mpz_sub(y, tx, x);
    mpz_mul(y, y, k);
    mpz_sub(y, y, ty);
    mpz_mod(y, y, p);
    
    mpz_set(tx, x);
    mpz_set(ty, y);
    /**add**/
    if(bits[i] == '1') {

      mpz_sub(inv, tx, gx);
      mpz_invert(inv, inv, p);
      mpz_sub(k, ty, gy);
      mpz_mul(k, k, inv);
      mpz_mod(k, k, p);

      mpz_pow_ui(x, k, 2);
      mpz_sub(x, x, tx);
      mpz_sub(x, x, gx);
      mpz_mod(x, x, p);

      mpz_sub(y, tx, x);
      mpz_mul(y, y, k);
      mpz_sub(y, y, ty);
      mpz_mod(y, y, p);
      
      mpz_set(tx, x);
      mpz_set(ty, y);
    }
  }
  mpz_clear(inv);
  mpz_clear(k);
  mpz_clear(tx);
  mpz_clear(ty);
}

void math_point_add(mpz_t x, mpz_t y, mpz_t x1, mpz_t y1, mpz_t x2, mpz_t y2, mpz_t p) {
  mpz_t t, k;
  mpz_init(t);
  mpz_init(k);

  mpz_sub(t, x1, x2);
  mpz_invert(t, t, p);
  mpz_sub(k, y1, y2);
  mpz_mul(k, k, t);
  mpz_mod(k, k, p);

  mpz_pow_ui(x, k, 2);
  mpz_sub(x, x, x1);
  mpz_sub(x, x, x2);
  mpz_mod(x, x, p);

  mpz_sub(y, x1, x);
  mpz_mul(y, y, k);
  mpz_sub(y, y, y1);
  mpz_mod(y, y, p);

  mpz_clear(k);
  mpz_clear(t);
}


static jclass _curve_cls      = NULL;
static jmethodID _constructor = NULL;
static jfieldID _x            = NULL;
static jfieldID _y            = NULL;
static jfieldID _Gx           = NULL;
static jfieldID _Gy           = NULL;
static jfieldID _P            = NULL;
static jfieldID _N            = NULL;
static jfieldID _A            = NULL;
static jfieldID _B            = NULL;


JNIEXPORT void JNICALL Java_com_archer_math_EcPoint_init
  (JNIEnv *env, jclass jcls) {
    _curve_cls = (*env)->FindClass(env, "com/archer/math/Curve");
    _constructor = (*env)->GetMethodID(env, jcls, "<init>", "()V");
    _x = (*env)->GetFieldID(env, jcls, "x", "[B");
    _y = (*env)->GetFieldID(env, jcls, "y", "[B");
    _Gx = (*env)->GetFieldID(env, _curve_cls, "Gx", "[B");
    _Gy = (*env)->GetFieldID(env, _curve_cls, "Gy", "[B");
    _P = (*env)->GetFieldID(env, _curve_cls, "P", "[B");
    _N = (*env)->GetFieldID(env, _curve_cls, "N", "[B");
    _A = (*env)->GetFieldID(env, _curve_cls, "A", "[B");
    _B = (*env)->GetFieldID(env, _curve_cls, "B", "[B");
}


JNIEXPORT jobject JNICALL Java_com_archer_math_EcPoint_add
  (JNIEnv *env, jclass jcls, jobject jpoint1, jobject jpoint2, jbyteArray jp) {
    if(NULL == jpoint1 || NULL == jpoint2 || NULL == jp) {
        return NULL;
    }
    jbyteArray jx1 = (*env)->GetObjectField(env, jpoint1, _x);
    jbyteArray jy1 = (*env)->GetObjectField(env, jpoint1, _y);
    jbyteArray jx2 = (*env)->GetObjectField(env, jpoint2, _x);
    jbyteArray jy2 = (*env)->GetObjectField(env, jpoint2, _y);

    uint32_t x1_len = (*env)->GetArrayLength(env, jx1);
    uint32_t y1_len = (*env)->GetArrayLength(env, jy1);
    uint32_t x2_len = (*env)->GetArrayLength(env, jx2);
    uint32_t y2_len = (*env)->GetArrayLength(env, jy2);
    uint32_t p_len = (*env)->GetArrayLength(env, jp);

    uint8_t x1c[x1_len], y1c[y1_len], x2c[x2_len], y2c[y2_len], pc[p_len];

    (*env)->GetByteArrayRegion(env, jx1, 0, x1_len, (jbyte *)x1c);
    (*env)->GetByteArrayRegion(env, jy1, 0, y1_len, (jbyte *)y1c);
    (*env)->GetByteArrayRegion(env, jx2, 0, x2_len, (jbyte *)x2c);
    (*env)->GetByteArrayRegion(env, jy2, 0, y1_len, (jbyte *)y2c);
    (*env)->GetByteArrayRegion(env, jp, 0, p_len, (jbyte *)pc);

    mpz_t x, y, x1, y1, x2, y2, p;
    mpz_init(x);
    mpz_init(y);
    mpz_init(x1);
    mpz_init(y1);
    mpz_init(x2);
    mpz_init(y2);
    mpz_init(p);

    mpz_import(x1, x1_len, 1, 1, 0, 0, x1c);
    mpz_import(y1, y1_len, 1, 1, 0, 0, y1c);
    mpz_import(x2, x2_len, 1, 1, 0, 0, x2c);
    mpz_import(y2, y2_len, 1, 1, 0, 0, y2c);
    mpz_import(p, p_len, 1, 1, 0, 0, pc);
    math_point_add(x, y, x1, y1, x2, y2, p);

    size_t lx = 32, ly = 32;
    uint8_t xc[32], yc[32];
    mpz_export(xc, &lx, 1, 1, 0, 0, x);
    mpz_export(yc, &ly, 1, 1, 0, 0, y);

    mpz_clear(x);
    mpz_clear(y);
    mpz_clear(x1);
    mpz_clear(y1);
    mpz_clear(x2);
    mpz_clear(y2);
    mpz_clear(p);

    jbyteArray rx = (*env)->NewByteArray(env, 32);
    if(NULL != rx) {
        (*env)->SetByteArrayRegion(env, rx, 32 - lx, lx, (jbyte *)xc);
    }
    jbyteArray ry = (*env)->NewByteArray(env, 32);
    if(NULL != ry) {
        (*env)->SetByteArrayRegion(env, ry, 32 - ly, ly, (jbyte *)yc);
    }

    jobject jobj = (*env)->NewObject(env, jcls, _constructor);
    if(NULL == jobj) {
      return NULL;
    }
    (*env)->SetObjectField(env, jobj, _x, rx);
    (*env)->SetObjectField(env, jobj, _y, ry);

    return jobj;
  }

JNIEXPORT jobject JNICALL Java_com_archer_math_EcPoint_sub
  (JNIEnv *env, jclass jcls, jobject jpoint1, jobject jpoint2, jbyteArray jp) {
    if(NULL == jpoint1 || NULL == jpoint2 || NULL == jp) {
        return NULL;
    }
    jbyteArray jx1 = (*env)->GetObjectField(env, jpoint1, _x);
    jbyteArray jy1 = (*env)->GetObjectField(env, jpoint1, _y);
    jbyteArray jx2 = (*env)->GetObjectField(env, jpoint2, _x);
    jbyteArray jy2 = (*env)->GetObjectField(env, jpoint2, _y);

    uint32_t x1_len = (*env)->GetArrayLength(env, jx1);
    uint32_t y1_len = (*env)->GetArrayLength(env, jy1);
    uint32_t x2_len = (*env)->GetArrayLength(env, jx2);
    uint32_t y2_len = (*env)->GetArrayLength(env, jy2);
    uint32_t p_len = (*env)->GetArrayLength(env, jp);

    uint8_t x1c[x1_len], y1c[y1_len], x2c[x2_len], y2c[y2_len], pc[p_len];

    (*env)->GetByteArrayRegion(env, jx1, 0, x1_len, (jbyte *)x1c);
    (*env)->GetByteArrayRegion(env, jy1, 0, y1_len, (jbyte *)y1c);
    (*env)->GetByteArrayRegion(env, jx2, 0, x2_len, (jbyte *)x2c);
    (*env)->GetByteArrayRegion(env, jy2, 0, y1_len, (jbyte *)y2c);
    (*env)->GetByteArrayRegion(env, jp, 0, p_len, (jbyte *)pc);


    mpz_t x, y, x1, y1, x2, y2, p, _0;
    mpz_init(x);
    mpz_init(y);
    mpz_init(x1);
    mpz_init(y1);
    mpz_init(x2);
    mpz_init(y2);
    mpz_init(p);
    mpz_init_set_si(_0, 0);

    mpz_import(x1, x1_len, 1, 1, 0, 0, x1c);
    mpz_import(y1, y1_len, 1, 1, 0, 0, y1c);
    mpz_import(x2, x2_len, 1, 1, 0, 0, x2c);
    mpz_import(y2, y2_len, 1, 1, 0, 0, y2c);
    mpz_import(p, p_len, 1, 1, 0, 0, pc);
    mpz_sub(y2, _0, y2);
    math_point_add(x, y, x1, y1, x2, y2, p);

    size_t lx = 32, ly = 32;
    uint8_t xc[32], yc[32];
    mpz_export(xc, &lx, 1, 1, 0, 0, x);
    mpz_export(yc, &ly, 1, 1, 0, 0, y);

    mpz_clear(x);
    mpz_clear(y);
    mpz_clear(x1);
    mpz_clear(y1);
    mpz_clear(x2);
    mpz_clear(y2);
    mpz_clear(p);
    mpz_clear(_0);

    jbyteArray rx = (*env)->NewByteArray(env, 32);
    if(NULL != rx) {
        (*env)->SetByteArrayRegion(env, rx, 32 - lx, lx, (jbyte *)xc);
    }
    jbyteArray ry = (*env)->NewByteArray(env, 32);
    if(NULL != ry) {
        (*env)->SetByteArrayRegion(env, ry, 32 - ly, ly, (jbyte *)yc);
    }
    jobject jobj = (*env)->NewObject(env, jcls, _constructor);
    if(NULL == jobj) {
      return NULL;
    }
    (*env)->SetObjectField(env, jobj, _x, rx);
    (*env)->SetObjectField(env, jobj, _y, ry);

    return jobj;
  }


JNIEXPORT jobject JNICALL Java_com_archer_math_EcPoint_mul
  (JNIEnv *env, jclass jcls, jbyteArray jd, jint curveId) {
    if(NULL == jd || (curveId != 1 && curveId != 2)) {
        return NULL;
    }
    
    
    uint32_t d_len = (*env)->GetArrayLength(env, jd);
    uint8_t dc[d_len];
    (*env)->GetByteArrayRegion(env, jd, 0, d_len, (jbyte *)dc);

    mpz_t x, y, d, p, a, b, gx, gy;
    mpz_init(x);
    mpz_init(y);
    mpz_init(d);
    mpz_init(p);
    mpz_init(a);
    mpz_init(b);
    mpz_init(gx);
    mpz_init(gy);

    if(curveId == 2) {
      uint8_t P[32] = {255, 255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255};
      uint8_t A[32] = {255, 255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 252};
      uint8_t B[32] = {40, 233, 250, 158, 157, 159, 94, 52, 77, 90, 158, 75, 207, 101, 9, 167, 243, 151, 137, 245, 21, 171, 143, 146, 221, 188, 189, 65, 77, 148, 14, 147};
      uint8_t Gx[32] = {50, 196, 174, 44, 31, 25, 129, 25, 95, 153, 4, 70, 106, 57, 201, 148, 143, 227, 11, 191, 242, 102, 11, 225, 113, 90, 69, 137, 51, 76, 116, 199};
      uint8_t Gy[32] = {188, 55, 54, 162, 244, 246, 119, 156, 89, 189, 206, 227, 107, 105, 33, 83, 208, 169, 135, 124, 198, 42, 71, 64, 2, 223, 50, 229, 33, 57, 240, 160};
      mpz_import(d, d_len, 1, 1, 0, 0, dc);
      mpz_import(p, 32, 1, 1, 0, 0, P);
      mpz_import(a, 32, 1, 1, 0, 0, A);
      mpz_import(b, 32, 1, 1, 0, 0, B);
      mpz_import(gx, 32, 1, 1, 0, 0, Gx);
      mpz_import(gy, 32, 1, 1, 0, 0, Gy);
    } else if(curveId == 1) {
      uint8_t P[32] = {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 255, 255, 252, 47};
      uint8_t Gx[32] = {121, 190, 102, 126, 249, 220, 187, 172, 85, 160, 98, 149, 206, 135, 11, 7, 2, 155, 252, 219, 45, 206, 40, 217, 89, 242, 129, 91, 22, 248, 23, 152};
      uint8_t Gy[32] = {72, 58, 218, 119, 38, 163, 196, 101, 93, 164, 251, 252, 14, 17, 8, 168, 253, 23, 180, 72, 166, 133, 84, 25, 156, 71, 208, 143, 251, 16, 212, 184};
      mpz_import(d, d_len, 1, 1, 0, 0, dc);
      mpz_import(p, 32, 1, 1, 0, 0, P);
      mpz_set_ui(a, 0);
      mpz_set_ui(b, 7);
      mpz_import(gx, 32, 1, 1, 0, 0, Gx);
      mpz_import(gy, 32, 1, 1, 0, 0, Gy);
    } else {
      return NULL;
    }
    math_point_mul(x, y, d, p, a, b, gx, gy);

    // {
    //   printf("x = %s\n", mpz_get_str(NULL, 16, x));
    //   printf("y = %s\n", mpz_get_str(NULL, 16, y));
    // }

    size_t lx = 32, ly = 32;
    uint8_t xc[32], yc[32];
    mpz_export(xc, &lx, 1, 1, 0, 0, x);
    mpz_export(yc, &ly, 1, 1, 0, 0, y);

    mpz_clear(x);
    mpz_clear(y);
    mpz_clear(d);
    mpz_clear(p);
    mpz_clear(a);
    mpz_clear(b);
    mpz_clear(gx);
    mpz_clear(gy);


    // {
    //   printf("lx = %d\n", lx);
    //   printf("ly = %d\n", ly);
    // }

    jbyteArray rx = (*env)->NewByteArray(env, 32);
    if(NULL != rx) {
        (*env)->SetByteArrayRegion(env, rx, 32 - lx, lx, (jbyte *)xc);
    }
    jbyteArray ry = (*env)->NewByteArray(env, 32);
    if(NULL != ry) {
        (*env)->SetByteArrayRegion(env, ry, 32 - ly, ly, (jbyte *)yc);
    }

    jobject jobj = (*env)->NewObject(env, jcls, _constructor);
    if(NULL == jobj) {
      return NULL;
    }
    (*env)->SetObjectField(env, jobj, _x, rx);
    (*env)->SetObjectField(env, jobj, _y, ry);

    return jobj;
  }

JNIEXPORT jobject JNICALL Java_com_archer_math_EcPoint_mulPoint
  (JNIEnv *env, jclass jcls, jbyteArray jd, jint curveId, jobject jpoint) {
    if(NULL == jd || (curveId != 1 && curveId != 2) || NULL == jpoint) {
        return NULL;
    }
    jbyteArray jx = (*env)->GetObjectField(env, jpoint, _x);
    jbyteArray jy = (*env)->GetObjectField(env, jpoint, _y);


    uint32_t x_len = (*env)->GetArrayLength(env, jx);
    uint32_t y_len = (*env)->GetArrayLength(env, jy);
    uint32_t d_len = (*env)->GetArrayLength(env, jd);

    uint8_t xc[x_len], yc[y_len], dc[d_len];

    (*env)->GetByteArrayRegion(env, jx, 0, x_len, (jbyte *)xc);
    (*env)->GetByteArrayRegion(env, jy, 0, y_len, (jbyte *)yc);
    (*env)->GetByteArrayRegion(env, jd, 0, d_len, (jbyte *)dc);

    mpz_t x, y, d, p, a, b, gx, gy;
    mpz_init(x);
    mpz_init(y);
    mpz_init(d);
    mpz_init(p);
    mpz_init(a);
    mpz_init(b);
    mpz_init(gx);
    mpz_init(gy);

    if(curveId == 2) {
      uint8_t P[32] = {255, 255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255};
      uint8_t A[32] = {255, 255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 252};
      uint8_t B[32] = {40, 233, 250, 158, 157, 159, 94, 52, 77, 90, 158, 75, 207, 101, 9, 167, 243, 151, 137, 245, 21, 171, 143, 146, 221, 188, 189, 65, 77, 148, 14, 147};
      uint8_t Gx[32] = {50, 196, 174, 44, 31, 25, 129, 25, 95, 153, 4, 70, 106, 57, 201, 148, 143, 227, 11, 191, 242, 102, 11, 225, 113, 90, 69, 137, 51, 76, 116, 199};
      uint8_t Gy[32] = {188, 55, 54, 162, 244, 246, 119, 156, 89, 189, 206, 227, 107, 105, 33, 83, 208, 169, 135, 124, 198, 42, 71, 64, 2, 223, 50, 229, 33, 57, 240, 160};
      mpz_import(d, d_len, 1, 1, 0, 0, dc);
      mpz_import(p, 32, 1, 1, 0, 0, P);
      mpz_import(a, 32, 1, 1, 0, 0, A);
      mpz_import(b, 32, 1, 1, 0, 0, B);
      mpz_import(gx, x_len, 1, 1, 0, 0, xc);
      mpz_import(gy, y_len, 1, 1, 0, 0, yc);
    } else if(curveId == 1) {
      uint8_t P[32] = {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 255, 255, 252, 47};
      uint8_t Gx[32] = {121, 190, 102, 126, 249, 220, 187, 172, 85, 160, 98, 149, 206, 135, 11, 7, 2, 155, 252, 219, 45, 206, 40, 217, 89, 242, 129, 91, 22, 248, 23, 152};
      uint8_t Gy[32] = {72, 58, 218, 119, 38, 163, 196, 101, 93, 164, 251, 252, 14, 17, 8, 168, 253, 23, 180, 72, 166, 133, 84, 25, 156, 71, 208, 143, 251, 16, 212, 184};
      mpz_import(d, d_len, 1, 1, 0, 0, dc);
      mpz_import(p, 32, 1, 1, 0, 0, P);
      mpz_set_si(a, 0);
      mpz_set_si(b, 7);
      mpz_import(gx, x_len, 1, 1, 0, 0, xc);
      mpz_import(gy, y_len, 1, 1, 0, 0, yc);
    }
    math_point_mul(x, y, d, p, a, b, gx, gy);

    size_t lx = 32, ly = 32;
    uint8_t rxc[32], ryc[32];
    mpz_export(rxc, &lx, 1, 1, 0, 0, x);
    mpz_export(ryc, &ly, 1, 1, 0, 0, y);

    mpz_clear(x);
    mpz_clear(y);
    mpz_clear(d);
    mpz_clear(p);
    mpz_clear(a);
    mpz_clear(b);
    mpz_clear(gx);
    mpz_clear(gy);

    jbyteArray rx = (*env)->NewByteArray(env, 32);
    if(NULL != rx) {
        (*env)->SetByteArrayRegion(env, rx, 32 - lx, lx, (jbyte *)rxc);
    }
    jbyteArray ry = (*env)->NewByteArray(env, 32);
    if(NULL != ry) {
        (*env)->SetByteArrayRegion(env, ry, 32 - ly, ly, (jbyte *)ryc);
    }
    jobject jobj = (*env)->NewObject(env, jcls, _constructor);
    if(NULL == jobj) {
      return NULL;
    }
    (*env)->SetObjectField(env, jobj, _x, rx);
    (*env)->SetObjectField(env, jobj, _y, ry);

    return jobj;
  }


/*
 * Class:     com_archer_math_EcPoint
 * Method:    mul
 * Signature: ([BLcom/archer/math/Curve;)Lcom/archer/math/EcPoint;
 */
JNIEXPORT jobject JNICALL Java_com_archer_math_EcPoint_mulCurve
  (JNIEnv *env, jclass jpcls, jbyteArray jd, jobject jcurve) {

    if(NULL == jd || NULL == jcurve) {
        return NULL;
    }
    
    jbyteArray jp = (*env)->GetObjectField(env, jcurve, _P);
    jbyteArray ja = (*env)->GetObjectField(env, jcurve, _A);
    jbyteArray jb = (*env)->GetObjectField(env, jcurve, _B);
    jbyteArray jgx = (*env)->GetObjectField(env, jcurve, _Gx);
    jbyteArray jgy = (*env)->GetObjectField(env, jcurve, _Gy);


    uint32_t d_len = (*env)->GetArrayLength(env, jd);
    uint32_t p_len = (*env)->GetArrayLength(env, jp);
    uint32_t a_len = (*env)->GetArrayLength(env, ja);
    uint32_t b_len = (*env)->GetArrayLength(env, jb);
    uint32_t gx_len = (*env)->GetArrayLength(env, jgx);
    uint32_t gy_len = (*env)->GetArrayLength(env, jgy);

    uint8_t dc[d_len], pc[p_len], ac[a_len], bc[b_len], gxc[gx_len], gyc[gy_len];

    (*env)->GetByteArrayRegion(env, jd, 0, d_len, (jbyte *)dc);
    (*env)->GetByteArrayRegion(env, jp, 0, p_len, (jbyte *)pc);
    (*env)->GetByteArrayRegion(env, ja, 0, a_len, (jbyte *)ac);
    (*env)->GetByteArrayRegion(env, jb, 0, b_len, (jbyte *)bc);
    (*env)->GetByteArrayRegion(env, jgx, 0, gx_len, (jbyte *)gxc);
    (*env)->GetByteArrayRegion(env, jgy, 0, gy_len, (jbyte *)gyc);

    mpz_t x, y, d, p, a, b, gx, gy;
    mpz_init(x);
    mpz_init(y);
    mpz_init(d);
    mpz_init(p);
    mpz_init(a);
    mpz_init(b);
    mpz_init(gx);
    mpz_init(gy);

    mpz_import(d, d_len, 1, 1, 0, 0, dc);
    mpz_import(p, p_len, 1, 1, 0, 0, pc);
    mpz_import(a, a_len, 1, 1, 0, 0, ac);
    mpz_import(b, b_len, 1, 1, 0, 0, bc);
    mpz_import(gx, gx_len, 1, 1, 0, 0, gxc);
    mpz_import(gy, gy_len, 1, 1, 0, 0, gyc);
    math_point_mul(x, y, d, p, a, b, gx, gy);

    size_t lx = p_len, ly = p_len;
    uint8_t xc[lx], yc[ly];
    mpz_export(xc, &lx, 1, 1, 0, 0, x);
    mpz_export(yc, &ly, 1, 1, 0, 0, y);

    mpz_clear(x);
    mpz_clear(y);
    mpz_clear(d);
    mpz_clear(p);
    mpz_clear(a);
    mpz_clear(b);
    mpz_clear(gx);
    mpz_clear(gy);

    jbyteArray rx = (*env)->NewByteArray(env, 32);
    if(NULL != rx) {
        (*env)->SetByteArrayRegion(env, rx, 32 - lx, lx, (jbyte *)xc);
    }
    jbyteArray ry = (*env)->NewByteArray(env, 32);
    if(NULL != ry) {
        (*env)->SetByteArrayRegion(env, ry, 32 - ly, ly, (jbyte *)yc);
    }
    jobject jobj = (*env)->NewObject(env, jpcls, _constructor);
    if(NULL == jobj) {
      return NULL;
    }
    (*env)->SetObjectField(env, jobj, _x, rx);
    (*env)->SetObjectField(env, jobj, _y, ry);

    return jobj;
  }

JNIEXPORT jobject JNICALL Java_com_archer_math_EcPoint_mulCurvePoint
  (JNIEnv *env, jclass jcls, jbyteArray jd, jobject jcurve, jobject jpoint) {

    if(NULL == jd || NULL == jcurve) {
        return NULL;
    }
    
    jbyteArray jp = (*env)->GetObjectField(env, jcurve, _P);
    jbyteArray ja = (*env)->GetObjectField(env, jcurve, _A);
    jbyteArray jb = (*env)->GetObjectField(env, jcurve, _B);
    jbyteArray jx = (*env)->GetObjectField(env, jpoint, _x);
    jbyteArray jy = (*env)->GetObjectField(env, jpoint, _y);


    uint32_t d_len = (*env)->GetArrayLength(env, jd);
    uint32_t p_len = (*env)->GetArrayLength(env, jp);
    uint32_t a_len = (*env)->GetArrayLength(env, ja);
    uint32_t b_len = (*env)->GetArrayLength(env, jb);
    uint32_t x_len = (*env)->GetArrayLength(env, jx);
    uint32_t y_len = (*env)->GetArrayLength(env, jy);

    uint8_t dc[d_len], pc[p_len], ac[a_len], bc[b_len], gxc[x_len], gyc[y_len];

    (*env)->GetByteArrayRegion(env, jd, 0, d_len, (jbyte *)dc);
    (*env)->GetByteArrayRegion(env, jp, 0, p_len, (jbyte *)pc);
    (*env)->GetByteArrayRegion(env, ja, 0, a_len, (jbyte *)ac);
    (*env)->GetByteArrayRegion(env, jb, 0, b_len, (jbyte *)bc);
    (*env)->GetByteArrayRegion(env, jx, 0, x_len, (jbyte *)gxc);
    (*env)->GetByteArrayRegion(env, jy, 0, y_len, (jbyte *)gyc);

    mpz_t x, y, d, p, a, b, gx, gy;
    mpz_init(x);
    mpz_init(y);
    mpz_init(d);
    mpz_init(p);
    mpz_init(a);
    mpz_init(b);
    mpz_init(gx);
    mpz_init(gy);

    mpz_import(d, d_len, 1, 1, 0, 0, dc);
    mpz_import(p, p_len, 1, 1, 0, 0, pc);
    mpz_import(a, a_len, 1, 1, 0, 0, ac);
    mpz_import(b, b_len, 1, 1, 0, 0, bc);
    mpz_import(gx, x_len, 1, 1, 0, 0, gxc);
    mpz_import(gy, y_len, 1, 1, 0, 0, gyc);
    math_point_mul(x, y, d, p, a, b, gx, gy);

    size_t lx = p_len, ly = p_len;
    uint8_t rxc[lx], ryc[ly];
    mpz_export(rxc, &lx, 1, 1, 0, 0, x);
    mpz_export(ryc, &ly, 1, 1, 0, 0, y);

    mpz_clear(x);
    mpz_clear(y);
    mpz_clear(d);
    mpz_clear(p);
    mpz_clear(a);
    mpz_clear(b);
    mpz_clear(gx);
    mpz_clear(gy);

    jbyteArray rx = (*env)->NewByteArray(env, 32);
    if(NULL != rx) {
        (*env)->SetByteArrayRegion(env, rx, 32 - lx, lx, (jbyte *)rxc);
    }
    jbyteArray ry = (*env)->NewByteArray(env, 32);
    if(NULL != ry) {
        (*env)->SetByteArrayRegion(env, ry, 32 - ly, ly, (jbyte *)ryc);
    }

    jobject jobj = (*env)->NewObject(env, jcls, _constructor);
    if(NULL == jobj) {
      return NULL;
    }
    (*env)->SetObjectField(env, jobj, _x, rx);
    (*env)->SetObjectField(env, jobj, _y, ry);

    return jobj;
  }


#ifdef __cplusplus
}
#endif
#endif
